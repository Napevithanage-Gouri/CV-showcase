---
title: "CM2605-Coursework"
author: "Gouri Napevithanage"
date: "2024-03-01"
output: word_document
---
```{r}

library(tidyverse) #includes a collection of packages for data manipulation and visualization.
library(simmer) #discrete-event simulation package.
library(simmer.plot) #for visualizing simulation results.
library(gridExtra) #for arranging multiple plots on one page.


#Question 1

set.seed(123)  # Set the seed for reproducibility

# Create a new simulation environment named "New Call Center"
env <- simmer("New Call Center")

# Define a trajectory for a customer
customer <- trajectory("customer") %>%
  seize("csr", 1) %>%  # Seize 1 customer service representative (csr)
  timeout(function() rexp(1,1/3)) %>%  # The customer spends an exponential amount of time (with mean 3) with the csr
  release("csr", 1)  # Release the csr

# Add resources and generators to the environment
env %>%
  add_resource("csr", 6) %>%  # Add 6 csrs to the environment
  add_generator("customer", customer, function() rpois(1,1))  # Add a generator for customers, with interarrival times following a Poisson distribution with lambda=1

# Run the simulation for 1440 units of time (e.g., minutes)
env %>% 
  run(until=1440)

# Plot the utilization of the csrs
plot(get_mon_resources(env), metric="utilization")

# Plot the flow time of the customers
plot(get_mon_arrivals(env), metric="flow_time")

# Plot the usage of the csrs
plot(get_mon_resources(env), metric="usage", item="server")
```


```{r}
#Question 2

set.seed(123)

# Define the number of samples
n <- 7000

# Generate voltage and resistance values
V <- rnorm(n, mean = 12, sd = 2)
R <- rnorm(n, mean = 8, sd = 1)

# Calculate power
P <- V^2 / R

# a) Generate 7000 values for power dissipated in a resistor
print(head(P))

# b) Create scatter plot to visualize relationship between power & voltage
plot(V, P, main = "Scatter plot of Power vs Voltage", xlab = "Voltage (V)", ylab = "Power (P)",col="darkgreen")

# c) Find approximate mean & variance of Power(P)
mean_P <- mean(P)
var_P <- var(P)
print(paste("Mean of Power: ", mean_P))
print(paste("Variance of Power: ", var_P))

# d) Estimate probability that Power(P) >20W
prob_P_gt_20 <- sum(P > 20) / n
print(paste("Probability that Power > 20W: ", prob_P_gt_20))
```


```{r}
#Question 3

set.seed(123)



# a) Generate N = 500 samples of size n = 50 from a Uniform[-5, 5] distribution

N <- 500 # Number of samples
n <- 50 # Size of each sample

samples500 <- replicate(N, runif(n, min = -5, max = 5))

# b) Find approximate mean & variance of the sample means

mean_samples500s <- colMeans(samples500) ## Calculate the mean of each sample

# c) Plot a histogram of these 500 sample means

hist(mean_samples500s, main = "Histogram of Sample Means", xlab = "Sample Mean",col="darkgreen")

#Yes, the distribution of sample means tends to be nearly normal when the sample size is large enough, regardless of the form of the population distribution. This is why the histogram of the 500 sample means should appear somewhat regular.


# d) Turn this simulation into a function

# Define a function for the simulation
simulate_sample_means <- function(N, n) {
  
  # Initialize a vector to store the sample means
  sample_means <- numeric(N)
  
  # Generate N samples and calculate their means
  for (i in 1:N) {
    # Generate a sample of size n from a Uniform[-5, 5] distribution
    sample <- runif(n, min = -5, max = 5)
    # Calculate the sample mean and store it
    sample_means[i] <- mean(sample)
  }
  
  # Return the sample means
  return(sample_means)
}

# e) Run this function for n = 10, 15, 30, 50

sample_sizes <- c(10, 15, 30, 50)
for (n in sample_sizes) {
  sample_means <- simulate_sample_means(N, n)
  hist(sample_means, main = paste("Histogram of Sample Means when n =", n), xlab = "Sample Mean",col="darkgreen")
}

  
#The histogram becomes increasingly symmetric and bell-shaped as the sample size grows.

```


```{r}
#Question 4

set.seed(123)

# Define a function for the simulation
random_walk <- function(N, n) {
  # Initialize a matrix to store the sample paths
  sample_paths <- matrix(nrow = N, ncol = n)
  
  # Generate N sample paths
  for (i in 1:N) {
    # Generate a sample of size n from the specified distribution
    sample <- sample(c(-1, 1), n, replace = TRUE)
    # Calculate the cumulative sum of the sample and store it
    sample_paths[i, ] <- cumsum(sample)
  }
  
  # Return the sample paths
  return(sample_paths)
}

# a) Simulate five realizations of the random walk {Sn,n ≥ 1}
N <- 5
n <- 1000  # You can adjust this as needed
sample_paths <- random_walk(N, n)

# Plot the sample paths
matplot(t(sample_paths), type = "l", main = "Realizations of the Random Walk", xlab = "Time", ylab = "Value")

# b) Discuss the aspects of the random variable Sn as n tends to infinity

# As n tends to infinity, the random walk {Sn, n ≥ 1} can take on a wider range of values, and its distribution becomes more spread out. This is consistent with the Central Limit Theorem, which states that the sum (or average) of a large number of independent and identically distributed random variables approaches a normal distribution.

```